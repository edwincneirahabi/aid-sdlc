---
description: Esta guía provee lineamientos para desarrollar con Next.js (frontend-only), cubriendo organización de código, performance, seguridad, pruebas y errores comunes.
globs: *.js,*.jsx,*.ts,*.tsx
---

# Buenas prácticas de Next.js

Este documento resume buenas prácticas para desarrollar con Next.js, enfocadas en organización de código, optimización de performance, seguridad, pruebas y errores comunes a evitar. Aplica a proyectos frontend-only (SSG).

## 1. Organización y estructura

### Estructura de directorios

- **`app/`**: (Next.js 15, App Router) estructura de rutas con Client Components (usa "use client" cuando aplique).
  - `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`, `head.tsx`
  - `[dynamic-segment]`, `@folder-name` (Route Groups)
- **`pages/`** (legado): componentes de página (`_app`, `_document`)
- **`components/`**, **`lib/`**, **`hooks/`**, **`styles/`**, **`public/`**, **`types/`**, **`utils/`**

**Recomendación:** Prefiere `app/` en proyectos nuevos; si usas `pages/`, mantenlo simple y migra cuando sea factible.

### Convenciones de nombres de archivo

- Componentes: `ComponentName.tsx`
- Pages: `page.tsx`
- Layouts: `layout.tsx`
- Hooks: `useHookName.ts`
- Styles: `ComponentName.module.css`
- Types: `types.ts` | `interfaces.ts`

### Organización de módulos

- Co‑location de componentes/estilos/tests
- Módulos por feature (no por tipo)
- Estructura poco profunda

### Arquitectura de componentes

- Separar presentacionales y contenedores
- Atomic Design (si aplica)
- Composición sobre herencia
- Solo Client Components

### Code splitting

- `next/dynamic` bajo demanda
- Split por ruta (por defecto)
- Fragmenta componentes grandes

## 2. Patrones y anti‑patrones

### Patrones de diseño

- HOCs, Render Props, Hooks, Context, Compound Components

### Enfoques recomendados

- Data fetching: solo cliente con `SWR` (fetch/axios). SSG para rutas estáticas; hidratar datos dinámicos en cliente.
- Estilos: Tailwind CSS (recomendado) o CSS Modules/Styled Components
- Estado: Zustand
- Formularios: `react-hook-form`

### Anti‑patrones y code smells

- Over‑fetching
- Bloquear el main thread
- Mutar estado directamente
- No memoizar componentes
- `useEffect` con dependencias incompletas
- Código de servidor en cliente (exposición de secretos)

### Manejo de estado

- `useState` local; `useContext` para estado global poco cambiante
- Librerías: Zustand/Jotai/Recoil

### Manejo de errores

- `try...catch` en async
- Error boundaries
- Logging centralizado (Sentry)
- `error.tsx` por segmento

## 3. Consideraciones de performance

### Técnicas de optimización

- `next/image`, `next/font`
- `next/dynamic` por componentes
- Caching de API (headers) y SWR
- `React.memo`
- `<Link prefetch>`
- SSG (sin SSR/ISR)
- `trailingSlash` y `basePath`: usar `trailingSlash: true` para servir carpetas (`/about/ -> /about/index.html`); `basePath` cuando se despliegue bajo subruta. Ver: [trailingSlash](https://nextjs.org/docs/app/api-reference/config/next-config-js/trailingSlash), [basePath](https://nextjs.org/docs/app/api-reference/config/next-config-js/basePath).

### Manejo de memoria

- Limpiar listeners/timers en `useEffect`
- Reducir re‑renders
- Estructuras inmutables

### Optimización de renderizado

- Solo Client Components; defer con `React.lazy` y dynamic imports

### Optimización de bundle

- Analizar bundle
- Tree‑shaking de código no usado
- Dependencias más livianas
- Compresión (Gzip/Brotli)

### Carga diferida (lazy)

- Imágenes con `next/image`
- Componentes con `next/dynamic`
- Intersection Observer cuando aplique

## 4. Buenas prácticas de seguridad

### Vulnerabilidades comunes

- XSS: sanitizar entrada; cuidado con `dangerouslySetInnerHTML`
- No exponer secretos; solo `NEXT_PUBLIC_` para valores no sensibles

### Validación de entrada

- Validación en cliente (feedback inmediato) pero no confiar para seguridad
- Sanitizar entrada
- Librerías: `zod` / `yup`

### Autenticación y autorización

- La maneja backend (fuera de alcance)

### Protección de datos

- HTTPS, cifrado en tránsito y reposo
- Dependencias actualizadas
- Variables de entorno sin secretos en cliente

### Comunicación segura con APIs

- HTTPS
- Autenticación por claves/tokens
- Validar parámetros
- Codificar salidas

### SWR por defecto (fetch en cliente)

- Provider global con `SWRConfig`
- Fetcher `fetch().then(r => r.json())`
- Sin revalidación en focus/reconnect por defecto
- Reintentos limitados con backoff (cuando aplique)

```tsx
'use client';
import { SWRConfig } from 'swr';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SWRConfig
      value={{
        fetcher: (resource, init) =>
          fetch(resource as RequestInfo, init).then((r) => r.json()),
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
        shouldRetryOnError: false,
        onErrorRetry: (error, _key, _config, revalidate, { retryCount }) => {
          // 4xx no reintenta; límite 3 intentos; backoff exponencial con jitter
          if (error?.status && error.status >= 400 && error.status < 500)
            return;
          if (retryCount >= 3) return;
          const delay = Math.min(
            1000 * 2 ** retryCount + Math.random() * 250,
            8000
          );
          setTimeout(() => revalidate({ retryCount }), delay);
        },
      }}
    >
      {children}
    </SWRConfig>
  );
}
```

## 5. Enfoques de testing

**IMPORTANTE**: Ver la estrategia de testing y cobertura en el documento/regla testing.md SECCION 6

## 6. Errores frecuentes y gotchas

### Errores frecuentes

- Usar SSR/ISR en stack solo‑frontend
- Complejizar estado (Redux innecesario)
- No optimizar imágenes
- Ignorar seguridad
- Testing insuficiente
- Exponer tokens/keys en cliente

### Casos borde

- Manejo de errores grácil
- Responsividad múltiple
- Compatibilidad de navegadores
- Estructuras de datos complejas

### Problemas por versión

- Breaking changes al actualizar Next.js
- Features deprecadas
- Compatibilidad con librerías de terceros

### Compatibilidad

- Navegadores objetivo
- Librerías externas compatibles con Next.js

### Convenciones del proyecto (Habi)

- **Next.js:** v15 con App Router
- **Componentes:** solo Client Components
- **Renderizado:** SSG; sin SSR/ISR
- **Datos:** REST; cliente con `SWR` (fetch/axios)
- **Auth:** backend
- **Estilos:** Tailwind + Keychain (TODO: alinear tokens/componentes con Keychain y flujo Figma Connect)
- **Formularios/Validación:** `react-hook-form` + `zod`
- **Imágenes/Fuentes:** `next/image` y `next/font`
- **Ruteo:** `<Link prefetch>`
- **Testing:** Jest + RTL; E2E con Playwright
- **Calidad:** ESLint (default), Prettier, TypeScript `strict: true`
- **Paquetes:** preferir `pnpm` (o `npm`)
- **Estructura:** sin monorepos; imports `@/*`
- **Observabilidad:** Sentry (por documentar)
